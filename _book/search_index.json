[
["introR.html", "Chapter 3 Data Structures 3.1 Recap: Data Types in R 3.2 Data Structures in R 3.3 Vectors 3.4 Data Frames 3.5 Working with data frames", " Chapter 3 Data Structures 3.1 Recap: Data Types in R In R, value has a type: Data Type Examples Integer (Numeric): …, -3, -2, -1, 0, +1, +2, +3, … Double (Numeric): most rational numbers; e.g., 1.0, 1.5, 20.0, pi Character: \"a\", \"b\", \"word\", \"hello dear friend, ...\" Logical: TRUE or FALSE (or: T or F ) Factor: Restricted, user-defined set of values, internally represented numerically (e.g., Gender {‘male’, ‘female’, ‘other’}) Ordered factor: Factor with an ordering (e.g., Starbucks coffee sizes {‘venti’ &gt; ‘grande’ &gt; ‘tall’}) 3.2 Data Structures in R All values in R are organized in data structures. Structures differ in their number of dimensions and in whether they allow mixed data types. In this course, we will mainly use vectors and data frames. dimensions types Vector 1-dimensional one type Matrix 2-dimensional one type Array n-dimensional one type data.frame 2-dimensional mixed types List 1-dimensional mixed types (Illustrations from Gaurav Tiwari’s article on medium here.) Let’s look at some examples # create and print vectors, don&#39;t save c(1,2, 1000) ## [1] 1 2 1000 c(1,2, 1000, pi) ## [1] 1.000000 2.000000 1000.000000 3.141593 1:3 ## [1] 1 2 3 # create and print a data.frame data.frame(1:3) ## X1.3 ## 1 1 ## 2 2 ## 3 3 3.3 Vectors Vectors are simply ordered lists of elements, where every element has the same type. They are useful for storing sets or sequences of numbers. Let’s create a simple vector with all integers from 1 to 8. vector_var &lt;- c(1,2,3,4,5,6,7,8) vector_var ## [1] 1 2 3 4 5 6 7 8 There is even a more elegant ways to do that: vector_var &lt;- 1:8 vector_var ## [1] 1 2 3 4 5 6 7 8 Now, let’s create a simple vector with integers between 1 and 8, going in steps of 2. vector_var &lt;- seq(1,8, by=2) vector_var ## [1] 1 3 5 7 Some useful vectors already exist in R. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; Some useful vectors already exist in R. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; We can select specific elements of a vector by indexing it with []. # the first letter letters[1] ## [1] &quot;a&quot; # the 13-th letter letters[13] ## [1] &quot;m&quot; Indices can be vectors too. # both of them letters[c(1,13)] ## [1] &quot;a&quot; &quot;m&quot; We can even take a whole ‘slice’ of a vector. # both of them letters[6:12] ## [1] &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; Indices can even be negative. A negative index \\(-n\\) means ‘everything’ except \\(n\\). # both of them letters[-1] ## [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; ## [20] &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; Vectors can be named. digits &lt;- c(&#39;one&#39;=1, &#39;two&#39;=2, &#39;three&#39;=3, &#39;four&#39;=4, &#39;five&#39;=5, &#39;six&#39;=6) In this case, we can index by the name digits[c(&#39;one&#39;, &#39;six&#39;)] ## one six ## 1 6 Believe it or not, everything in R is actually a vector. For example 9 is a vector with only one element, which is 9. 9 ## [1] 9 This is why every output begins with [1]. R tries to help you find numbers in printed vectors. Every time a vector is printed, it reminds you at which position in the vector we are. The [1] in the output below tells you that \"a\" is the first element, and the [20] tells you that \"t\" is the 20-th element. letters # print a vector with all lower-case letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 3.3.1 What are vectors good for? Let’s put this knowledge to use. Here are two vectors representing the winnings from my recent gambling: horse_bets_payout_tl &lt;- c(100, -50, 1, 100, -10, -20, 250, -40, -30, 23, -23, 55, 14, 8, 24, -3) poker_payout_tl &lt;- c(24, 5, -38.1, 12, 103, 15, 5, 187, 13, -23, -45, 36) Let’s find out which game is more profitable … sum(horse_bets_payout_tl) ## [1] 399 sum(poker_payout_tl) ## [1] 293.9 … we may also need these functions: length(horse_bets_payout_tl) ## [1] 16 mean(horse_bets_payout_tl) ## [1] 24.9375 sum(horse_bets_payout_tl)/length(horse_bets_payout_tl) ## [1] 24.9375 … so which game is more profitable? It seems that betting is more profitable. mean(horse_bets_payout_tl) ## [1] 24.9375 mean(poker_payout_tl) ## [1] 24.49167 Now, I forgot to mention that my bookie charges me 1.5 TL per bet on a horse, on average. The poker payouts correspond to the profits, though. Luckily, we can just add numbers and vectors. Let’s just create two new vectors which contain the profits. Let’s subtract 1.5 from elements of horse_bets_payout_tl and save the result as horse_bets_profits_tl. horse_bets_profits_tl &lt;- horse_bets_payout_tl - 1.5 For poker, we don’t need to change anything. poker_profits_tl &lt;- poker_payout_tl Let’s compare: horse_bets_payout_tl ## [1] 100 -50 1 100 -10 -20 250 -40 -30 23 -23 55 14 8 24 -3 horse_bets_profits_tl ## [1] 98.5 -51.5 -0.5 98.5 -11.5 -21.5 248.5 -41.5 -31.5 21.5 -24.5 53.5 ## [13] 12.5 6.5 22.5 -4.5 poker_payout_tl ## [1] 24.0 5.0 -38.1 12.0 103.0 15.0 5.0 187.0 13.0 -23.0 -45.0 36.0 poker_profits_tl ## [1] 24.0 5.0 -38.1 12.0 103.0 15.0 5.0 187.0 13.0 -23.0 -45.0 36.0 Which game is more profitable now? mean(horse_bets_profits_tl) ## [1] 23.4375 mean(poker_profits_tl) ## [1] 24.49167 3.4 Data Frames What I forgot to mention is that I generally gamble on Wednesdays and Fridays. Maybe that matters? How can we associate this information with the profits vectors? One way is to represent it in two vectors containing days of the week. In that case, every \\(i\\)-th element in poker_week_days corresponds to the \\(i\\)-th element in poker_week_days. # create two vectors with week days horse_bets_week_days &lt;- rep(c(&quot;Wed&quot;, &quot;Fr&quot;), 8) poker_week_days &lt;- rep(c(&quot;Wed&quot;, &quot;Fr&quot;), 6) But this is getting messy. We have to keep track of two pairs a vectors, and the relations between them. Let’s represent all poker-related information in one data structure, and all horse race-related information in another structure. The best way to represent a pair of vectors where the \\(i\\)-th element in vector 1 corresponds to the \\(i\\)-th element in vector 2 is with data frames (data.frame). df_horse_bets &lt;- data.frame(wday = horse_bets_week_days, profit = horse_bets_profits_tl) df_poker &lt;- data.frame(wday = poker_week_days, profit = poker_payout_tl) Let’s take a look at what we’ve created. df_horse_bets ## wday profit ## 1 Wed 98.5 ## 2 Fr -51.5 ## 3 Wed -0.5 ## 4 Fr 98.5 ## 5 Wed -11.5 ## 6 Fr -21.5 ## 7 Wed 248.5 ## 8 Fr -41.5 ## 9 Wed -31.5 ## 10 Fr 21.5 ## 11 Wed -24.5 ## 12 Fr 53.5 ## 13 Wed 12.5 ## 14 Fr 6.5 ## 15 Wed 22.5 ## 16 Fr -4.5 Wow. That’s a rather long output … Generally, it’s sufficient to see the first couple of lines of a data.frame to get a sense of what it contains. We’ll use the function head(), which takes a data.frame and a number \\(n\\), and outputs the first \\(n\\) lines. head(df_horse_bets, 2) ## wday profit ## 1 Wed 98.5 ## 2 Fr -51.5 An alternative is View(), which shows you the entire data.frame in the RStudio GUI. View(df_poker) Turning back to our gambling example, we still have two objects, which really belong together. Let’s merge them into one long data frame. The function rbind() takes two data frames as its arguments, and returns a single concatenated data frame, where all the rows of the first data frame are on top, and all the rows of the second data frame are at the bottom. df_gambling &lt;- rbind(df_horse_bets, df_poker) Unfortunately, now, we don’t have any information on which profits are from which game. head(df_gambling) ## wday profit ## 1 Wed 98.5 ## 2 Fr -51.5 ## 3 Wed -0.5 ## 4 Fr 98.5 ## 5 Wed -11.5 ## 6 Fr -21.5 Let’s fix this problem by enriching both data frames with this information. df_horse_bets$game &lt;- &quot;horse_bets&quot; df_poker$game &lt;- &quot;poker&quot; Now, let’s bind them together again. (This overwrites the old data frame called df_gambling, which we created previously.) df_gambling &lt;- rbind(df_horse_bets, df_poker) head(df_gambling) ## wday profit game ## 1 Wed 98.5 horse_bets ## 2 Fr -51.5 horse_bets ## 3 Wed -0.5 horse_bets ## 4 Fr 98.5 horse_bets ## 5 Wed -11.5 horse_bets ## 6 Fr -21.5 horse_bets 3.5 Working with data frames Now, we can do very cool things very easily. But we’ll need two packages for that: dplyr, and magrittr. # load the two packages library(magrittr) # for &#39;%&gt;%&#39; library(dplyr) # for group_by() and summarize() ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union Now, we can ‘aggregate’ data (= “combine data from several measurements by replacing it by summary statistics”). Let’s compute the average profit by game. df_gambling %&gt;% group_by(game) %&gt;% summarize(avg_profit = mean(profit)) ## # A tibble: 2 x 2 ## game avg_profit ## &lt;chr&gt; &lt;dbl&gt; ## 1 horse_bets 23.4 ## 2 poker 24.5 We can also aggregate over several grouping variables, like game and wday. df_gambling %&gt;% group_by(game, wday) %&gt;% summarize(avg_profit = mean(profit)) ## # A tibble: 4 x 3 ## # Groups: game [2] ## game wday avg_profit ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 horse_bets Fr 7.62 ## 2 horse_bets Wed 39.2 ## 3 poker Fr 38.7 ## 4 poker Wed 10.3 … and we can do so in various ways. Here we compute the proportion of wins. df_gambling %&gt;% group_by(game, wday) %&gt;% summarize(avg_proportion_wins = mean(profit&gt;0) ) ## # A tibble: 4 x 3 ## # Groups: game [2] ## game wday avg_proportion_wins ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 horse_bets Fr 0.5 ## 2 horse_bets Wed 0.5 ## 3 poker Fr 0.833 ## 4 poker Wed 0.667 Now, we can also plot the results. But we’ll need to save them first. profits_by_game &lt;- df_gambling %&gt;% group_by(game) %&gt;% summarize(avg_profit = mean(profit)) profits_by_game_and_wday &lt;- df_gambling %&gt;% group_by(game, wday) %&gt;% summarize(avg_profit = mean(profit)) We will also need yet another package: ggplot2. library(ggplot2) ggplot(profits_by_game, aes(game, avg_profit)) + geom_point() library(ggplot2) ggplot(profits_by_game_and_wday, aes(game, avg_profit, color = wday, group = wday)) + geom_point() + geom_line() library(ggplot2) ggplot(profits_by_game, aes(game, avg_profit)) + geom_bar(stat = &quot;identity&quot;) library(ggplot2) ggplot(profits_by_game_and_wday, aes(game, avg_profit, fill = wday)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) "]
]
