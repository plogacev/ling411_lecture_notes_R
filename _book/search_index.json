[["working-with-data.html", "Chapter 4 Working with data 4.1 Summarizing data 4.2 Working with dplyr 4.3 Pipes 4.4 Functions used in this section", " Chapter 4 Working with data .r-output { font-weight: bold; } .function { background-color: lightgrey; padding: 0.5em 0.5em 0.5em 4em; border: 1px solid black; } Today, let’s work with realistic data. In order to access it, we’ll need to load the R package languageR. It provides a number of interesting data sets related to language. You may need to install it, if it’s not already installed: install.packages(&quot;languageR&quot;) Let’s load the package and take a look at the data set. library(languageR) head(dativeSimplified) ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## 1 NP feed animate inanimate 2.639057 ## 2 NP give animate inanimate 1.098612 ## 3 NP give animate inanimate 2.564949 ## 4 NP give animate inanimate 1.609438 ## 5 NP offer animate inanimate 1.098612 ## 6 NP give animate inanimate 1.386294 This data set happens to be documented. Let’s take a look at its description. (You can also see it here. ) help(&quot;dativeSimplified&quot;) The dative alternation in English is the alternation between (1) and (2). Both are grammatical and have the same truth conditions. Bresnan et al. (2007) used this data to determine which factors affect the choice between (1) and (2). Peter gave Mary the book. Peter gave the book to Mary. Let’s take a look at a few rows chosen at random to get a look at a more representative sample … # store all possible row indices in a vector indices_all &lt;- 1:nrow(dativeSimplified) # set the random seed to make the results reproducible set.seed(123) # choose 10 such numbers at random without replacement indices_random &lt;- sample(indices_all, size = 10) # use them to index the data frame to get the corresponding rows dativeSimplified[indices_random,] ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## 415 NP give inanimate inanimate 1.7917595 ## 463 NP grant animate inanimate 1.0986123 ## 179 NP grant animate inanimate 2.3978953 ## 526 NP give animate inanimate 2.5649494 ## 195 NP tell animate inanimate 3.2580965 ## 818 PP give animate inanimate 0.0000000 ## 118 NP pay animate inanimate 0.6931472 ## 299 NP hand animate inanimate 0.6931472 ## 229 NP give inanimate inanimate 1.6094379 ## 244 NP wish animate inanimate 1.0986123 The above code works because rows and columns of data frames can be selected (‘indexed’) df[row_indices, ] selects rows \\(-\\) df[, col_indices] selects columns df[row_indices, col_indices] selectes rows and columns This works with row and column names, as well as indices. 4.1 Summarizing data Let’s take a look at the percentages of NP realizations of the recipient by animacy of theme. # load the package dplyr to access the group_by/summarize functions library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union # let&#39;s take a look at the key dependent variable unique(dativeSimplified$RealizationOfRec) ## [1] NP PP ## Levels: NP PP # now, compute the percentages (perc_NP) and the number of observations in each subset dativeSimplified %&gt;% group_by(AnimacyOfRec) %&gt;% dplyr::summarize(perc_NP = mean(RealizationOfRec == &quot;NP&quot;), N = n() ) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 3 ## AnimacyOfRec perc_NP N ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 animate 0.634 822 ## 2 inanimate 0.420 81 4.1.1 Now, step by step Wow, that was easy. … But let’s break down the computations into their elementary parts and take look at the logic … First, we’ll need to add a column which we can later use to compute the percentage of NP realizations. # first, let&#39;s create a new column encoding whether RealizationOfRec is &#39;NP&#39; dativeSimplified$is_realization_NP &lt;- as.integer( dativeSimplified$RealizationOfRec == &quot;NP&quot; ) Take a subset of the data frame where AnimacyOfRec equals “animate” (note the ==!). # take a look at the values that can occur in this columns unique(dativeSimplified$AnimacyOfRec) ## [1] animate inanimate ## Levels: animate inanimate # take two subsets corresponding to the values we determined above df_animate &lt;- subset(dativeSimplified, AnimacyOfRec == &quot;animate&quot;) df_inanimate &lt;- subset(dativeSimplified, AnimacyOfRec == &quot;inanimate&quot;) Compute the average of the column is_realization_NP in each data frame, as well as the number of rows in it. # compute the percentage of NP realizations perc_NP_animate = mean(df_animate$is_realization_NP) # compute the percentage of NP realizations N_animate = nrow(df_animate) # bind to data frame (res_animate &lt;- data.frame(AnimacyOfRec = &quot;animate&quot;, perc_NP = perc_NP_animate, N=N_animate)) ## AnimacyOfRec perc_NP N ## 1 animate 0.63382 822 Now, do the same for inanimates. perc_NP_inanimate = mean(df_inanimate$is_realization_NP) N_inanimate = nrow(df_inanimate) (res_inanimate &lt;- data.frame(AnimacyOfRec = &quot;inanimate&quot;, perc_NP = perc_NP_animate, N=N_animate)) ## AnimacyOfRec perc_NP N ## 1 inanimate 0.63382 822 Now, bind the results into a single data frame, which we can use for plotting, creating tables, etc. res &lt;- rbind(res_animate, res_inanimate) res ## AnimacyOfRec perc_NP N ## 1 animate 0.63382 822 ## 2 inanimate 0.63382 822 Puuuuuh. That was tedious. The disadvantages of the subset-approach are: Values of ‘game’ need to be known, and so the code needs to be adjusted to the contents of the dataset Much less tractable for more grouping variables Better options are available 4.2 Working with dplyr The package dplyr (cheat sheet) provides a set of functions for working with data frames Some of functions don’t perform a noticeable action, while others reshape data frames or create new ones (the latter are called ‘verbs’) library(dplyr) arrange() sorts the data frame by one or several columns By default, it does so in ascending order. arrange(dative[1:10,], LengthOfTheme) ## Speaker Modality Verb SemanticClass LengthOfRecipient AnimacyOfRec ## 8 &lt;NA&gt; written bring a 1 animate ## 10 &lt;NA&gt; written give a 1 animate ## 2 &lt;NA&gt; written give a 2 animate ## 5 &lt;NA&gt; written offer c 2 animate ## 6 &lt;NA&gt; written give a 2 animate ## 7 &lt;NA&gt; written pay t 2 animate ## 4 &lt;NA&gt; written give a 1 animate ## 9 &lt;NA&gt; written teach a 1 animate ## 3 &lt;NA&gt; written give a 1 animate ## 1 &lt;NA&gt; written feed t 1 animate ## DefinOfRec PronomOfRec LengthOfTheme AnimacyOfTheme DefinOfTheme ## 8 definite pronominal 1 inanimate indefinite ## 10 definite pronominal 2 inanimate indefinite ## 2 definite nonpronominal 3 inanimate indefinite ## 5 definite nonpronominal 3 inanimate definite ## 6 definite nonpronominal 4 inanimate indefinite ## 7 definite nonpronominal 4 inanimate indefinite ## 4 definite pronominal 5 inanimate indefinite ## 9 definite pronominal 11 inanimate indefinite ## 3 definite nonpronominal 13 inanimate definite ## 1 definite pronominal 14 inanimate indefinite ## PronomOfTheme RealizationOfRecipient AccessOfRec AccessOfTheme ## 8 nonpronominal NP given new ## 10 nonpronominal NP given accessible ## 2 nonpronominal NP given new ## 5 nonpronominal NP given new ## 6 nonpronominal NP given new ## 7 nonpronominal NP given new ## 4 nonpronominal NP given new ## 9 nonpronominal NP given accessible ## 3 nonpronominal NP given new ## 1 nonpronominal NP given new The modifier desc() switches arrange() to an decending order. arrange(dative[1:10,], desc(LengthOfTheme)) ## Speaker Modality Verb SemanticClass LengthOfRecipient AnimacyOfRec ## 1 &lt;NA&gt; written feed t 1 animate ## 3 &lt;NA&gt; written give a 1 animate ## 9 &lt;NA&gt; written teach a 1 animate ## 4 &lt;NA&gt; written give a 1 animate ## 6 &lt;NA&gt; written give a 2 animate ## 7 &lt;NA&gt; written pay t 2 animate ## 2 &lt;NA&gt; written give a 2 animate ## 5 &lt;NA&gt; written offer c 2 animate ## 10 &lt;NA&gt; written give a 1 animate ## 8 &lt;NA&gt; written bring a 1 animate ## DefinOfRec PronomOfRec LengthOfTheme AnimacyOfTheme DefinOfTheme ## 1 definite pronominal 14 inanimate indefinite ## 3 definite nonpronominal 13 inanimate definite ## 9 definite pronominal 11 inanimate indefinite ## 4 definite pronominal 5 inanimate indefinite ## 6 definite nonpronominal 4 inanimate indefinite ## 7 definite nonpronominal 4 inanimate indefinite ## 2 definite nonpronominal 3 inanimate indefinite ## 5 definite nonpronominal 3 inanimate definite ## 10 definite pronominal 2 inanimate indefinite ## 8 definite pronominal 1 inanimate indefinite ## PronomOfTheme RealizationOfRecipient AccessOfRec AccessOfTheme ## 1 nonpronominal NP given new ## 3 nonpronominal NP given new ## 9 nonpronominal NP given accessible ## 4 nonpronominal NP given new ## 6 nonpronominal NP given new ## 7 nonpronominal NP given new ## 2 nonpronominal NP given new ## 5 nonpronominal NP given new ## 10 nonpronominal NP given accessible ## 8 nonpronominal NP given new select() keeps only the pre-specified columns from the data frame # select(dative, game, profit) ## Error: Can&#39;t subset columns that don&#39;t exist. ## [31mx[39m Column `game` doesn&#39;t exist. left_join merges two data frames by common columns. This is very useful when data comes from two different sources. df1 &lt;- data.frame(name = c(&quot;Peter&quot;, &quot;Mary&quot;, &quot;Susy&quot;, &quot;John&quot;), n_apples = c(2,3,4,1)) df2 &lt;- data.frame(name = c(&quot;Peter&quot;, &quot;Mary&quot;, &quot;Susy&quot;), n_oranges = c(1,20,0)) df &lt;- dplyr::left_join(df1, df2) ## Joining, by = &quot;name&quot; df$n_fruit &lt;- df$n_apples + df$n_oranges sample_n shows a few random rows from the data frame sample_n(dativeSimplified, 10) ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## 14 NP give animate inanimate 0.6931472 ## 374 NP sell animate inanimate 0.0000000 ## 665 PP give animate inanimate 1.6094379 ## 602 PP pay animate inanimate 1.3862944 ## 603 PP offer inanimate inanimate 1.9459101 ## 768 PP sell animate inanimate 1.6094379 ## 709 PP give animate inanimate 0.0000000 ## 91 NP give animate inanimate 2.0794415 ## 348 NP cost animate inanimate 0.6931472 ## 649 PP sell animate inanimate 1.0986123 ## is_realization_NP ## 14 1 ## 374 1 ## 665 0 ## 602 0 ## 603 0 ## 768 0 ## 709 0 ## 91 1 ## 348 1 ## 649 0 group_by and ungroup add and remove information about grouping variables # let&#39;s &#39;group&#39; a small subset of the gambling data frame by game group_by(dativeSimplified[1:2,], RealizationOfRec) ## # A tibble: 2 x 6 ## # Groups: RealizationOfRec [1] ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 NP feed animate inanimate 2.64 ## 2 NP give animate inanimate 1.10 ## # … with 1 more variable: is_realization_NP &lt;int&gt; # let&#39;s compare to the original data frame dativeSimplified[1:2,] ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## 1 NP feed animate inanimate 2.639057 ## 2 NP give animate inanimate 1.098612 ## is_realization_NP ## 1 1 ## 2 1 data frames need to be grouped for use with summarize() and mutate() # let&#39;s group the dativeSimplified data frame dativeSimplified_grouped &lt;- group_by(dativeSimplified, Verb) summarize() divides a grouped data frame into subsets, with each subset corresponding to one value of the grouping variable (or a combination of values for several grouping variables), … … and computes one or several values on each such subset # summarize several variables summarize(dativeSimplified_grouped, prop_NP = mean(is_realization_NP), prop_animate_rec = mean( AnimacyOfRec == &quot;animate&quot; ), prop_animate_theme = mean( AnimacyOfTheme == &quot;animate&quot; ), N = n() ) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 65 x 5 ## Verb prop_NP prop_animate_rec prop_animate_theme N ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 accord 1 1 0 1 ## 2 allocate 0 0 0 3 ## 3 allow 1 0.833 0 6 ## 4 assess 1 1 0 1 ## 5 assure 1 1 0 2 ## 6 award 0.389 0.944 0 18 ## 7 bequeath 0 1 0 1 ## 8 bet 1 1 0 1 ## 9 bring 0.545 0.818 0 11 ## 10 carry 0 1 0 1 ## # … with 55 more rows summarize() can use the results of previous computations # compute the averages of profit summarize(dativeSimplified_grouped, prop_NP = mean(is_realization_NP), prop_PP = 1-prop_NP, how_many_NP_realizations = ifelse(prop_NP &gt; 0.5, &quot;a lot&quot;, &quot;few&quot;) ) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 65 x 4 ## Verb prop_NP prop_PP how_many_NP_realizations ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 accord 1 0 a lot ## 2 allocate 0 1 few ## 3 allow 1 0 a lot ## 4 assess 1 0 a lot ## 5 assure 1 0 a lot ## 6 award 0.389 0.611 few ## 7 bequeath 0 1 few ## 8 bet 1 0 a lot ## 9 bring 0.545 0.455 a lot ## 10 carry 0 1 few ## # … with 55 more rows The last line uses the function ifelse(condition, value1, value2), which, for each element of the condition vector returns the corresponding element of the value1 vector if the condition is true at that element, or an element of vector2 otherwise. mutate() proceeds similarly to summarize() in dividing a grouped dataset into subsets, but instead of computing one or several values for each subset, it creates or modifies a column A very simple application is to simply create a new column. In this case, we don’t even need to group # these two lines performs exactly the same action, except the latter stores the result in df dativeSimplified$is_realization_NP &lt;- (dativeSimplified$RealizationOfRec == &quot;NP&quot; ) df &lt;- mutate(dativeSimplified, is_realization_NP = (RealizationOfRec == &quot;NP&quot;) ) head(df, 2) ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## 1 NP feed animate inanimate 2.639057 ## 2 NP give animate inanimate 1.098612 ## is_realization_NP ## 1 TRUE ## 2 TRUE head(dativeSimplified, 2) ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## 1 NP feed animate inanimate 2.639057 ## 2 NP give animate inanimate 1.098612 ## is_realization_NP ## 1 TRUE ## 2 TRUE 4.3 Pipes 4.3.1 The problem The code below is really hard to read, even harder to maintain, and dativeSimplified_grouped_by_AnimacyOfRec_and_AnimacyOfTheme is a terribly long variable name. dativeSimplified_grouped_by_AnimacyOfRec_and_AnimacyOfTheme &lt;- group_by(dativeSimplified, AnimacyOfRec, AnimacyOfTheme) df &lt;- summarize(dativeSimplified_grouped_by_AnimacyOfRec_and_AnimacyOfTheme, perc_NP = mean(RealizationOfRec == &quot;NP&quot;) ) ## `summarise()` regrouping output by &#39;AnimacyOfRec&#39; (override with `.groups` argument) df ## # A tibble: 4 x 3 ## # Groups: AnimacyOfRec [2] ## AnimacyOfRec AnimacyOfTheme perc_NP ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 animate animate 0.8 ## 2 animate inanimate 0.633 ## 3 inanimate animate 1 ## 4 inanimate inanimate 0.412 This alternative is also quite bad. To read this code, you need to know which bracket matches which other bracket. df &lt;- summarize(group_by(dativeSimplified, AnimacyOfRec, AnimacyOfTheme), perc_NP = mean(RealizationOfRec == &quot;NP&quot;) ) ## `summarise()` regrouping output by &#39;AnimacyOfRec&#39; (override with `.groups` argument) df ## # A tibble: 4 x 3 ## # Groups: AnimacyOfRec [2] ## AnimacyOfRec AnimacyOfTheme perc_NP ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 animate animate 0.8 ## 2 animate inanimate 0.633 ## 3 inanimate animate 1 ## 4 inanimate inanimate 0.412 One nested function call may be OK. But try to read this. df &lt;- dplyr::summarize(group_by(mutate(dativeSimplified, long_theme = ifelse(LengthOfTheme &gt; 1.6, &quot;long&quot;, &quot;short&quot;) ), long_theme), perc_NP = mean(RealizationOfRec == &quot;NP&quot;) ) ## `summarise()` ungrouping output (override with `.groups` argument) Or consider this expression (sqrt is the square root.) sqrt(divide_by(sum(divide_by(2,3), multiply_by(2,3)), sum(3,4))) ## Error in divide_by(sum(divide_by(2, 3), multiply_by(2, 3)), sum(3, 4)): could not find function &quot;divide_by&quot; Luckily, there a better way to write this expression. 4.3.2 Pipes The problem is that we have too many levels of embedding. In natural language we avoid multiple embeddings of that sort by making shorter sentences, and using anaphors to refer to previous discourse. The packages dplyr and magrittr provide a limited version of such functionality, and we’ll need to use pipe operators (%&gt;% and %&lt;&gt;%) to link expressions with an ‘anaphoric dependency’. # Typical notation. Read as &quot;Divide 10 by 2.&quot; divide_by(10, 2) ## Error in divide_by(10, 2): could not find function &quot;divide_by&quot; # Equivalent pipe notation. Read as &quot;Take 10, and divide it by 2.&quot; 10 %&gt;% divide_by(., 2) ## Error in divide_by(., 2): could not find function &quot;divide_by&quot; # Equivalent pipe notation. Read as &quot;Take 2, and divide 10 by it.&quot; 2 %&gt;% divide_by(10, .) ## Error in divide_by(10, .): could not find function &quot;divide_by&quot; If the dot operator occurs in the first argument slot, it can be omitted. (R has pro-drop.) # pipe notation with omission of &#39;.&#39; 10 %&gt;% divide_by(2) ## Error in divide_by(., 2): could not find function &quot;divide_by&quot; Let’s see how it can resolve the mess below. (Repetition of previous example.) df &lt;- mutate(group_by(dativeSimplified, AnimacyOfRec, AnimacyOfTheme), perc_NP = mean(RealizationOfRec == &quot;NP&quot;) ) df ## # A tibble: 903 x 7 ## # Groups: AnimacyOfRec, AnimacyOfTheme [4] ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 NP feed animate inanimate 2.64 ## 2 NP give animate inanimate 1.10 ## 3 NP give animate inanimate 2.56 ## 4 NP give animate inanimate 1.61 ## 5 NP offer animate inanimate 1.10 ## 6 NP give animate inanimate 1.39 ## 7 NP pay animate inanimate 1.39 ## 8 NP bring animate inanimate 0 ## 9 NP teach animate inanimate 2.40 ## 10 NP give animate inanimate 0.693 ## # … with 893 more rows, and 2 more variables: is_realization_NP &lt;lgl&gt;, ## # perc_NP &lt;dbl&gt; And here is the much more readable version of this code: df &lt;- dativeSimplified %&gt;% mutate(., long_theme = ifelse(LengthOfTheme &gt; 1.6, &quot;long&quot;, &quot;short&quot;) ) %&gt;% group_by(., long_theme) %&gt;% dplyr::summarize(., perc_NP = mean(RealizationOfRec == &quot;NP&quot;) ) ## `summarise()` ungrouping output (override with `.groups` argument) We don’t actually need the dot: df &lt;- dativeSimplified %&gt;% mutate(long_theme = ifelse(LengthOfTheme &gt; 1.6, &quot;long&quot;, &quot;short&quot;) ) %&gt;% group_by(long_theme) %&gt;% dplyr::summarize(perc_NP = mean(RealizationOfRec == &quot;NP&quot;) ) ## `summarise()` ungrouping output (override with `.groups` argument) The %&lt;&gt;% operator is a convenient combination of %&gt;% and &lt;- which you can use to directly modify an object. # load the package magrittr in order to access the assignment pipe operator library(magrittr) # create a vector with numbers from 1 to 10 x &lt;- 1:10 # keep only numbers &lt; 5: # (i) without %&lt;&gt;% x &lt;- x[x&lt;5] # (i) with %&lt;&gt;% x %&lt;&gt;% .[.&lt;5] # lets add several columns to &#39;dativeSimplified&#39; dativeSimplified %&lt;&gt;% mutate(A=1, B=2, C=3, D=4) head(dativeSimplified) ## RealizationOfRec Verb AnimacyOfRec AnimacyOfTheme LengthOfTheme ## 1 NP feed animate inanimate 2.639057 ## 2 NP give animate inanimate 1.098612 ## 3 NP give animate inanimate 2.564949 ## 4 NP give animate inanimate 1.609438 ## 5 NP offer animate inanimate 1.098612 ## 6 NP give animate inanimate 1.386294 ## is_realization_NP A B C D ## 1 TRUE 1 2 3 4 ## 2 TRUE 1 2 3 4 ## 3 TRUE 1 2 3 4 ## 4 TRUE 1 2 3 4 ## 5 TRUE 1 2 3 4 ## 6 TRUE 1 2 3 4 4.4 Functions used in this section 4.4.1 Operators %&gt;% (Forward) pipe: Use the expression on the left as a part of the expression on the right. Read x %&gt;% fn as ‘use x as the only argument of function fn’. Read x %&gt;% fn(1, 2) as ‘use x as the first argument of function fn’. Read x %&gt;% fn(1, ., 2) as ‘use x as the second argument of function fn’. %&lt;&gt;% Assignment pipe: Use the expression on the left as a part of the expression on the right, and assign the result back to the left part of the expression. x %&lt;&gt;% ... is equivalent to x &lt;- x %&gt;% ... Read x %&lt;&gt;% fn as ‘use x as the only argument of function fn, and assign it the result to x’. Read x %&lt;&gt;% fn(1, 2) as ‘use x as the first argument of function fn, and assign it the result to x’. Read x %&lt;&gt;% fn(1, ., 2) as ‘use x as the second argument of function fn, and assign it the result to x’. df[selected_rows, indices_columns] Indexing operator: Accesses specific rows and/or columns of a data frame. selected_rows A vector of indices or names. selected_columns A vector of indices or names. :: Double colon operator: Accesses functions and other objects from packages. Read x::y as ‘y from package x.’ 4.4.2 Functions help(name) Displays the documentation for an object, such as a function or data frame in R. object Must be a function or data frame currently loaded in R. If the package in which the function or dataset are located is not currently loaded, the name must be specified using the double-colon operator, i.e., as package::name. For example, help('dplyr::summarize'). ifelse(condition, val_if_cond_true, val_if_cond_false) Replaces all occurrences of TRUE by val_if_cond_true, and all occurrences of FALSE by val_if_cond_false and returns the resulting vector. If val_if_cond_true and val_if_cond_false are vectors, the elements of condition at every index \\(i\\) are replaces by val_if_cond_true[i] and val_if_cond_false[i], respectively. unique(object) Return only the unique values in an object. That is, return each value that occurs in vector or data frame object exactly once. For vectors, this means unique values. For data frames, this means unique rows. object A vector, matrix, or data frame. nrow(object) Return the number of rows in object. object A data frame or matrix. ncol(object) Return the number of columns in object. object A data frame or matrix. sample(vector, size = length(vector), replace = FALSE) Select a number of random elements from vector. If size == length(vector), the vector is just returned in randomly permuted order. vector The vector from which to sample. size How many elements to sample. Must be smaller than or equal to the length of vector, which is the default. replace Logical. Sample with replacement? (i.e., Can the same element be sampled several times?) Defaults to FALSE. group_by(df, grouping_var1, ...) Records the grouping of a data frame for future application of summarize() or mutate(). df A data frame. grouping_var1 The first grouping variable. ... More grouping variables, if applicable. summarize(df, expression1, ...) Computes a series of summary statistics for each combination of values specified by the levels of the grouping variables, for example compute the average of a column. df A data frame, typically previously grouped using group_by. expression1 An expression computing a summary statistics. ... An expression computing summary statistics. mutate(df, expression1, ...) Modify and old column, or create a new one for each combination of grouping variable levels. df A data frame, typically previously grouped using group_by. expression1 An expression creating a new column, or modifying an old one. ... More expressions creating new columns, or modifying an old ones. n() Within a call to summarize() or mutate(), n() computes the number of rows at each combination of grouping variable levels. arrange() select() sample_n() "]]
